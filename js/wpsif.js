// NOTE: About the current state of compatibility to the MS Word integration.
// This addon try to be compatible with the MS Word integration.
// It does this by storing data to documents in a format close to the MS integration.
// While pretending like a Google Docs integration when talking to the Zotero server.
// Currently, in a documented created using this addon,
// only the CSL `formattedCitation` data in the code of the fields are not identical to that generated by the MS integration.
// This is because I haven't found a good solution yet to convert RTF to/from XML.
// However, from what I've tested, this won't cause any problem for normal users.
// Since Zotero will automatically update the CSL data as it discovers the mismatches.
// So, the citations created in either MS Word or WPS can be edited/updated in either enivornments without encumberness.


const zc_consts = {
    zoteroLink: 'https://www.zotero.org/',
    citationHead: 'ITEM CSL_CITATION ',
    citationHeadM: 'ADDIN ZOTERO_ITEM CSL_CITATION ',
    tempCitation: 'TEMP',
    tempCitationText: '{Updating}',
    bibHead: 'BIBL ',
    bibHeadM: 'ADDIN ZOTERO_BIBL ',
    exportedHead: 'ZOTERO_TRANSFER_DOCUMENT',
    exportedPrefHead: 'DOCUMENT_PREFERENCES ',
    prefDocDataName: 'ZOTERO_PREF',
    bibStyleDocDataName: '_ZOTERO_BIBSTYLE',
    placeholderUrl: 'https://www.zotero.org/?',
    colorMap: {
        // Gray
        0xaaaaaa: wps.Enum.wdGray50,
        // Blue
        0x2ea8e5: wps.Enum.wdBlue,
        // Magenta
        0xe56eee: wps.Enum.wdPink,
        // Violet
        0xa28ae5: wps.Enum.wdViolet,
        // Green
        0x5fb236: wps.Enum.wdGreen,
        // Orange
        0xf19837: wps.Enum.wdDarkYellow,
        // Red
        0xff6666: wps.Enum.wdRed,
        // Yellow
        0xffd400: wps.Enum.wdYellow
    }
}

function zc_matchHighlightColor(color) {
    const colors = Object.keys(zc_consts.colorMap).map((x) => parseInt(x));
    const matched = matchColor(color, colors);
    return zc_consts.colorMap[matched];
}

/**
 * Get the document object in Application.Documents.
 * Default to current document if the argument is not given.
 * We have this function because document objects are not strictly and uniquely mapped to documents.
**/
function zc_getDocumentInDocuments(doc) {
    if (!doc) return doc;
    // Application.ActiveDocument is always the same object.
    const doc0 = doc ? doc :Application.ActiveDocument.FullName; 
    const fullName = doc0.FullName;
    for (let i = 1; i <= Application.Documents.Count; i++) {
        const doc1 = Application.Documents.Item(i);
        if (doc1.FullName === fullName) {
            return doc1;
        }
    }
    throw new Error("Can't find document in collection!");
}

// Was desgined to contain the records of all opening documents.
// But wps objects can't be held as references for too long.
// So this registry gets cleaned after every transaction and would only contain one record.
let zc_registry = {
    id_client: {},
    id_doc: {},
    doc_client: {},
    doc_id: {},
};

/**
 * Clear all entries in the registry.
 * Should be called as soon as possible.
 * It's not safe to keep references on wps objects.
**/
function zc_clearRegistry() {
    zc_registry = {
        id_client: {},
        id_doc: {},
        doc_client: {},
        doc_id: {},
    };
}

function zc_getDocumentById(id) {
    return id ? zc_registry.id_doc[id] : null;
}

function zc_getClientById(id) {
    return id ? zc_registry.id_client[id] : null;
}

function zc_getDocumentId(doc) {
    if (doc) {
        const doc_ = zc_getDocumentInDocuments(doc);
        return zc_registry.doc_id[doc_];
    }
    return null;
}

function zc_registryAdd(id, client, doc) {
    if (id && client && doc) {
        const doc_ = zc_getDocumentInDocuments(doc);
        zc_registry.id_client[id] = client;
        zc_registry.id_doc[id] = doc_;
        zc_registry.doc_client[doc_] = client;
        zc_registry.doc_id[doc_] = id;
        return true;
    }
    return false;
}

function zc_registryRemove(doc) {
    if (doc) {
        const doc_ = zc_getDocumentInDocuments(doc);
        id = zc_registry.doc_id[doc_];
        client = zc_registry.doc_client[doc_];
        if (id && client) {
            delete zc_registry.id_client[id];
            delete zc_registry.id_doc[id];
            delete zc_registry.doc_client[doc_];
            delete zc_registry.doc_id[doc_];
            return true;
        } 
        else {
            return false;
        }
    }
    else {
        return false;
    }
}

/**
 * Scan for fields and register all citation fields.
**/
function zc_indexCitationFields(doc) {
    const docId = zc_getDocumentId(doc);
    const client = zc_getClientById(docId);
    // Fields in main text.
    for (let i = 1; i <= doc.Fields.Count; i++) {
        client.registerField(doc.Fields.Item(i));
    }
    // Fields in footnotes
    for (let i = 1; i <= doc.Footnotes.Count; i++) {
        const range = doc.Footnotes.Item(i).Range;
        for (let j = 1; j <= range.Fields.Count; j++) {
            client.registerField(range.Fields.Item(j));
        }
    }
    // TODO: Scan for fields in endnotes as well in future if endnote is to be supported.
    const n = client.getFieldCount();
    console.debug(`Found ${n} fields in total.`);
    return n;
}

/**
 * Get the version of document data string by trying to parse it.
**/
function zc_testDocDataVer(dataStr) {
    let version = null;
    if (dataStr) {
        version = 4
        try {
            JSON.parse(dataStr);
        }
        catch {
            version = 3;
            if (!parseXML(dataStr)) {
                throw new Error(`Invalid document data (neither json or xml): ${dataStr}`);
            }
        }
    }
    else {
        version = 3;
    }
    return version;
}

/**
 * Convert the xml document data string (version 3) to JSON string (version 4).
**/
function zc_xmlDocData2Json(xmlStr) {
    const xml = parseXML(xmlStr);
    if (!xml) return null;
    let data = {
        "style": {
            "styleID": xml.getElementsByTagName('style').item(0).getAttribute('id'),
            "hasBibliography": Boolean(xml.getElementsByTagName('style').item(0).getAttribute('hasBibliography')),
            "bibliographyStyleHasBeenSet": Boolean(xml.getElementsByTagName('style').item(0).getAttribute('bibliographyStyleHasBeenSet'))
        },
        "prefs": {},
        "sessionID": xml.getElementsByTagName('session').item(0).getAttribute('id'),
        "zoteroVersion": xml.getElementsByTagName('data').item(0).getAttribute('zotero-version'),
        "dataVersion": Number(xml.getElementsByTagName('data').item(0).getAttribute('data-version'))
    }
    for (const pref of xml.getElementsByTagName('pref')) {
        const name = pref.getAttribute('name');
        let value = pref.getAttribute('value');
        if (name === 'automaticJournalAbbreviations' || name === 'delayCitationUpdates') {
            value = Boolean(Number(value));
        }
        data["prefs"][name] = value;
    }
    const jsonStr = JSON.stringify(data);
    return jsonStr;
}

/**
 * Set custom document property.
**/
function zc_setDocProperty(doc, name, dataStr) {
    assert(doc);
    const props = doc.CustomDocumentProperties;

    // delete previous record
    for (let i = props.Count; i > 0; i--) {
        const p = props.Item(i);
        // NOTE: don't use includes, it will return false
        if (p.Name.indexOf(name) >= 0) {
            p.Delete();
        }
    }

    // add new record
    const len = dataStr.length;
    const segCount = parseInt(len / 255) + 1;
    for (let i = 0; i < segCount; i++) {
        const seg = dataStr.substring(i*255, len > (i+1)*255 ? (i+1)*255 : len);
        props.Add(`${name}_${i+1}`, false, wps.Enum.msoPropertyTypeString, seg)
    }
}

/**
 * Get custom document property.
**/
function zc_getDocProperty(doc, name) {
    assert(doc);
    const props = doc.CustomDocumentProperties;
    let propStr = '';
    for (let i = 1; i <= props.Count; i++) {
        const p = props.Item(i);
        // NOTE: don't use includes, it will return false
        if (p.Name.indexOf(name) >= 0) {
            propStr += p.Value;
        }
    }
    return propStr;
}

/**
 * Create and bind a new zotero client to the given document.
**/
function zc_bind(doc) {
    const doc_ = doc ? doc : Application.ActiveDocument;
    // return the existing client if already registered
    const tmp = zc_getDocumentId(doc_);
    if (tmp) return zc_getClientById(tmp);
    
    // create new client
    const id = makeId(36);
    console.debug(`add client id = ${id}`);
    const client = zc_createClient(id, zc_wps);

    // bind id, client, doc with each other
    zc_registryAdd(id, client, doc_);

    // bind citation fields with ids
    client.fields = {};
    client.getFieldCount = function() {
        return Object.keys(this.fields).length;
    }
    client.getField = function(fId) {
        return fId ? client.fields[fId] : null;
    };
    client.getFieldId = function(field) {
        // Compare indexes rather than objects. Direct compare will always fail since the api creates new objects for every call. Also note that holding references on anyone of them will cause problems.
        if (field) {
            for (const fId in this.fields) {
                const f = this.fields[fId];
                if (f && f.Index === field.Index) {
                    return fId;
                }
            }
        }
    };
    client.clearAllFieldIds = function() {
        this.fields = {};
    };
    client.unregisterField = function(field) {
        let ret = false;
        if (field) {
            for (const fId in this.fields) {
                const f = this.fields[fId];
                if (f && f.Index === field.Index) {
                    delete this.fields[fId];
                    ret = true;
                }
            }
        }
        return ret;
    }
    /**
     * Add a new field to client's field registry.
     * Only succeed when it's a citation field.
     * Return the newly assigned ID of the field, null if failed.
    **/
    client.registerField = function (field, id) {
        if (field && field.Index > 0) {
            // return the field ID if already registered.
            let fId = this.getFieldId(field);
            if (fId) {
                return fId;
            }
            // check if it's a citation field.
            if (zc_isZoteroField(field)) {
                fId = id ? id : makeId(10);
                while ((fId in this.fields) == true) {
                    fId = makeId(10);
                }
                this.fields[fId] = field;
                return fId;
            }
            return null;
        }
    };

    /**
     * Replace a record.
    **/
    client.replaceField = function (fId, field) {
        if (fId && field && field.Index > 0) {
            if (zc_isZoteroField(field)) {
                this.fields[fId] = field;
                return true;
            }
        }
        return false;
    };

    return client;
}

/**
 * Collapse current selection to its end,
 * performa an operation and recover the selection.
**/
function zc_doWithoutSelection(doc, op) {
    const sel = doc.ActiveWindow.Selection;
    let sStart = sel.Start;
    let sEnd = sel.End;

    // clear selection
    sel.Collapse(wps.Enum.wdCollapseEnd);
    const cur = sel.Start;

    // perform operation (selection object, cursor position)
    const ret = op(sel, cur);

    // recover selection
    sel.Start = sStart;
    sel.End = sEnd;

    return ret;
}

/**
 * Insert a word text XML node to the given range.
 * Support for formatting tags are limited.
**/
function zc_insertXMLNode(range, node, disableHyperlinks) {
    const common_tags = ['div', 'html', 'body'];
    if (!node || node.nodeType === undefined) {
        console.warn(`${node} is not a node!`);
        return -1;
    }
    // Insert all texts
    range.InsertAfter(node.textContent);
    const rStart = range.Start;
    const rEnd = range.End;
    // Format the texts
    function _format(_range, _node) {
        let _rStart = _range.Start;
        let _rEnd = _range.End;
        if (_node.nodeType === domElmType.ELEMENT_NODE) {
            switch (_node.nodeName) {
                case 'p':
                    break;
                case 'br':
                    _range.Collapse(wps.Enum.wdCollapseStart);
                    _range.InsertBreak(wps.Enum.wdLineBreak);
                    // Delete the placeholder
                    _range.Collapse(wps.Enum.wdCollapseEnd);
                    _range.Delete(wps.Enum.wdCharacter, 1);
                    break;
                case 'span':
                    const style = _node.getAttribute('style');
                    if (style === 'text-decoration: line-through') {
                        _range.Font.StrikeThrough = true;
                    }
                    else if (style.indexOf('color: ') === 0) {
                        // The name is RGB, but it's actually GBR, so we need to reverse it. the API is a fucking mess.
                        const color = parseColor(style.substr('color: '.length), true);
                        assert(color);
                        _range.Font.TextColor.RGB = color;
                    }
                    else if (style.indexOf('background-color') === 0) {
                        // The name is RGB, and it's actually RGB.
                        const color = parseColor(style.substr('background-color: '), true);
                        assert(color);
                        // Match a pre-defined highlight color index
                        const hl = zc_matchHighlightColor(color)
                        _range.HighlightColorIndex = hl;
                        // _range.Font.Fill.Solid();
                        // _range.Font.Fill.BackColor.RGB = color;
                    }
                    else {
                        log.warn(`Span style: ${style} not supported yet!`);
                    }
                    break;
                case 'h1':
                    _range.Style = wps.Enum.wdStyleHeading1;
                    break;
                case 'h2':
                    _range.Style = wps.Enum.wdStyleHeading2;
                    break;
                case 'h3':
                    _range.Style = wps.Enum.wdStyleHeading3;
                    break;
                case 'ul':
                    _range.ListFormat.ApplyBulletDefault();
                    break;
                case 'ol':
                    _range.ListFormat.ApplyNumberDefault();
                    break;
                case 'li':
                    break;
                case 'blockquote':
                    const fmt = _range.Paragraphs.Format;
                    // Both APA and MLA use 0.5 cm indent for block quotes.
                    fmt.LeftIndent = cm2pt(0.5);
                    break;
                case 'pre':
                    // MS Word integration didn't do this either.
                    if (_node.hasAttributes()) {
                        if (_node.hasAttribute('class') && _node.getAttribute('class') === 'math') {
                            console.debug('equation is not supported!');
                            // WPS won't parse things like '^' or '_'.
                            // To make this work will need a equation parser.
                            // Do nothing because equation env is different on Windows and the following piece of code will cause error.
                            break;
                            
                            let text = _range.Text;
                            // Remove guarding $$
                            text = text.substring(2);
                            text = text.substr(0, text.length-2);
                            // Remove equation text
                            _range.Text = '';
                            // Create a math environment and move the equation text into it.
                            const mrange = _range.OMaths.Add(_range);
                            const om = mrange.OMaths.Item(1);
                            om.Range.Text = ' ';
                            om.Range.InsertAfter(text);
                            om.BuildUp();
                        }
                    }
                    else {
                        console.debug('monospace is not supported!');

                        // NOTE: Can't do this.
                        // Because there's no safe monospace fonts on Linux and setting one that doesn't exist will freeze WPS.
                        // Also, WPS won't accept `monospace` as a valid font name.

                        // no attribute defaults to monospaced
                        // const font = GLOBAL_MAP.isWin ? 'Courier New' : 'monospace';
                        // _range.Font.Name = font;
                    }
                    break;
                case 'sup':
                    _range.Font.Superscript = true;
                    break;
                case 'sub':
                    _range.Font.Subscript.Italic = true;
                    break;
                case 'b':
                    _range.Font.Bold = true;
                    break;
                case 'i':
                    _range.Font.Italic = true;
                    break;
                case 'a':
                    if (!disableHyperlinks) {
                        const addr = _node.getAttribute('href');
                        _range.Hyperlinks.Add(_range, addr);
                    }
                    break;
                case 'u':
                    _range.Font.Underline = true;
                    break;
                default:
                    if (common_tags.indexOf(_node.nodeName) < 0) {
                        console.warn(`Formating with <${_node.nodeName}> tag is not implemented yet!`);
                    }
                    break;
            }
        }
        _range.Start = _rStart;
        _range.End = _rEnd;
        _range.Collapse(wps.Enum.wdCollapseEnd);
        // Process child nodes in reverse order so the <br> trick won't change textContent.length
        const children = _node.childNodes;
        for (let i = children.length - 1; i >= 0; i--) {
            const child = children.item(i);
            _range.MoveStart(wps.Enum.wdCharacter, -child.textContent.length);
            _rStart = _range.Start;
            _rEnd = _range.End;
            _format(_range, child);
            _range.Start = _rStart;
            _range.End = _rEnd;
            _range.Collapse(wps.Enum.wdCollapseStart);
        }
    }
    _format(range, node);
    // Selects all inserted texts.
    range.Start = rStart;
    range.End = rEnd;
    return node.textContent.length;
}

/**
 * Insert a xml str as rich text.
**/
function zc_insertRichText(range, rich, disableHyperlinks) {
    // Remove extra line ends
    let xmlStr = rich.replaceAll('\r', '');
    xmlStr = xmlStr.replaceAll('\n', '');
    // Turn <br> to <br/>
    // Trick: Add a placeholder character that will later be deleted.
    xmlStr = xmlStr.replaceAll('<br>', '<br/>|');
    // Turn <p> to \n
    xmlStr = xmlStr.replaceAll('</p>', '\n</p>');
    // Add \n after li
    xmlStr = xmlStr.replaceAll('</li>', '</li>\n');
    // Add \n after pre
    xmlStr = xmlStr.replaceAll('</pre>', '</pre>\n');
    // Add \n after h1, h2 and h3
    xmlStr = xmlStr.replaceAll('</h1>', '</h1>\n');
    xmlStr = xmlStr.replaceAll('</h2>', '</h2>\n');
    xmlStr = xmlStr.replaceAll('</h3>', '</h3>\n');
    // Replace <em> with <i>
    xmlStr = xmlStr.replaceAll('<em>', '<i>');
    xmlStr = xmlStr.replaceAll('</em>', '</i>');
    // Replace <strong> with <b>
    xmlStr = xmlStr.replaceAll('<strong>', '<b>');
    xmlStr = xmlStr.replaceAll('</strong>', '</b>');
    const xml = parseXML(xmlStr);
    if (xml) {
        return zc_insertXMLNode(range, xml.firstChild, disableHyperlinks) >= 0;
    }
    console.warn(`Failed to parse xml: ${rich}!`);
    return false;
}

/**
 * Insert xml bibliography entries 
**/
function zc_insertBibEntries(range, xmlStr, bibStyle) {
    assert(bibStyle);
    const xml = parseXML(xmlStr);
    assert(xml);
    const rStart = range.Start;
    const entries = xml.getElementsByClassName('csl-entry');
    for (let i = 0; i < entries.length; i++) {
        const entry = entries.item(i);
        const left = entry.getElementsByClassName('csl-left-margin').item(0);
        const right = entry.getElementsByClassName('csl-right-inline').item(0);
        if (left) {
            // Enabling hyperlinks in bib will soemhow cause incorrect formatting.
            zc_insertXMLNode(range, left, true);
            range.Collapse(wps.Enum.wdCollapseEnd);
            range.InsertAfter('\t'.repeat(bibStyle.tabStopsCount));
            range.Collapse(wps.Enum.wdCollapseEnd);
            if (right) {
                zc_insertXMLNode(range, right, true);
                range.Collapse(wps.Enum.wdCollapseEnd);
            }
        }
        else {
            if (right) {
                zc_insertXMLNode(range, right, true);
                range.Collapse(wps.Enum.wdCollapseEnd);
            }
            else {
                zc_insertXMLNode(range, entry, true);
                range.Collapse(wps.Enum.wdCollapseEnd);
            }
        }
        // Only create new paragraphs for subsequent entries.
        // So the the field is not ended by invisible characters which can cause problems.
        if (i !== entries.length - 1) {
            range.InsertParagraph();
            range.Collapse(wps.Enum.wdCollapseEnd);
        }
    }
    // Whole range
    range.Start = rStart;
    // Set paragraph style
    const fmt = range.Paragraphs.Format;
    fmt.FirstLineIndent = twip2pt(bibStyle.firstLineIndent);
    fmt.LeftIndent = twip2pt(bibStyle.indent);
    fmt.LineSpacing = twip2pt(bibStyle.lineSpacing);
    fmt.SpaceAfter = twip2pt(bibStyle.entrySpacing);
    fmt.TabStops.ClearAll();
    for (let ts in bibStyle.tabStops) {
        fmt.TabStops.Add(twip2pt(ts), wps.Enum.wdAlignTabLeft);
    }
    // fmt.Alignment = wps.Enum.wdAlignParagraphJustify;
    return entries.length;
}

/**
 * Get bibliography style data from custom document property or by extracting from the bibliography field (then write to document property).
**/
function zc_getBibStyle(doc, bibField) {
    let bibStyle = null;
    // Get bibliography style from custom document property.
    const bibStyleStr = zc_getDocProperty(doc, zc_consts.bibStyleDocDataName);
    if (bibStyleStr) {
        bibStyle = JSON.parse(bibStyleStr);
    }
    else {
        // Extract from the field.
        console.warn('Missing bibliography style, try to extract it from the bib field.');
        const text = bibField.Result.Text;
        if (text) {
            const m = text.match(new RegExp('\\t+'));
            if (m) {
                const tabStopsCount = m[0].length;
                const range = bibField.Result;
                const fmt = range.ParagraphFormat;
                const tabStops = []
                for (let i = 1; i <= fmt.TabStops.Count; i++) {
                    tabStops.push(pt2twip(fmt.TabStops.Item(i).Position));
                }
                bibStyle = {
                    firstLineIndent: pt2twip(fmt.FirstLineIndent),
                    indent: pt2twip(fmt.LeftIndent),
                    lineSpacing: pt2twip(fmt.LineSpacing),
                    entrySpacing: pt2twip(fmt.SpaceAfter),
                    tabStops: tabStops,
                    tabStopsCount: tabStopsCount
                };
                // Store as custom property.
                zc_setDocProperty(doc, zc_consts.bibStyleDocDataName, JSON.stringify(bibStyle));
            }
        }
    }
    return bibStyle;
}

function zc_isZoteroField(field) {
    // NOTE: Zotero will try to set temp field code to `{}`, but we don't take that order because it will result in invisible fields. As a workaround, we keep `TEMP` as the code for temp fields, but report to Zotero it's `{}`.
    return (
        field.Code.Text.indexOf(zc_consts.citationHead) === 0 ||
        field.Code.Text.indexOf(zc_consts.citationHeadM) === 1 ||
        field.Code.Text.indexOf(zc_consts.tempCitation) === 0 ||
        field.Code.Text.indexOf(zc_consts.bibHead) === 0 ||
        field.Code.Text.indexOf(zc_consts.bibHeadM) === 1
    );
}

/**
 * Move the citation field from footnote to main text.
**/
function zc_moveFieldToMain(field) {
    const doc = zc_getDocumentInDocuments(field.Result.Document);
    const docId = zc_getDocumentId(doc);
    const client = zc_getClientById(docId);
    const fId = client.getFieldId(field);
    assert(fId);
    // Change noteIndex to 0 in code.
    let code = field.Code.Text;
    let csl = zc_getCslData(field);
    csl.properties.noteIndex = 0;
    code = code.substring(0, code.indexOf('{')) + JSON.stringify(csl);
    // Acquire the footnote of which the field resides in.
    const footnotes = field.Result.Footnotes;
    assert(footnotes.Count === 1);
    const footnote = footnotes.Item(1);
    // Move to footnote start in main text.
    let range = footnote.Reference;
    range.Collapse(wps.Enum.wdCollapseStart);
    // Delete the old field and footnote
    field.Delete();
    footnote.Delete();
    // Create new field at the footnote's reference range.
    const newField = zc_createCitationField(range);
    assert(client.replaceField(fId, newField));
    newField.Code.Text = code;
}

/**
 * Move the citation field from main text to footnote.
**/
function zc_moveFieldToFootnote(field) {
    const doc = zc_getDocumentInDocuments(field.Result.Document);
    const docId = zc_getDocumentId(doc);
    const client = zc_getClientById(docId);
    const fId = client.getFieldId(field);
    assert(fId);
    let code = field.Code.Text;
    // Change noteIndex to 1.
    let csl = zc_getCslData(field);
    csl.properties.noteIndex = 1;
    code = code.substring(0, code.indexOf('{')) + JSON.stringify(csl);
    // Create footnote at the range of the old field and move to footnote.
    let range = field.Result;
    range.Collapse(wps.Enum.wdCollapseStart);
    // Delete old field
    // Must do this before creating footnote or the footnote field will merge with the old field and gets deleted all together.
    field.Delete()
    const footnote = doc.Footnotes.Add(range);
    range = footnote.Range;
    // Create new field in footnote.
    const newField = zc_createCitationField(range);
    assert(client.replaceField(fId, newField));
    newField.Code.Text = code;
}

/**
 * Convert a zotero field to a text of its code and add the hyperlink of Zotero.
**/
function zc_convertFieldToHyperlink(field) {
    if (zc_isZoteroField(field)) {
        const range = field.Result;
        range.Collapse(wps.Enum.wdCollapseStart);
        const code = zc_tweakFieldCode(field.Code.Text, 'Google');
        field.Delete();
        range.InsertAfter(code);
        range.Hyperlinks.Add(range, zc_consts.zoteroLink);
    }
}

function zc_convertHyperlinkToField(hyperlink) {
    if (hyperlink.Address === zc_consts.zoteroLink) {
        const range = hyperlink.Range;
        range.Collapse(wps.Enum.wdCollapseStart);
        const code = hyperlink.TextToDisplay;
        // Exported format is compatible to Google Docs.
        const cIdx = code.indexOf(zc_consts.citationHead);
        const bIdx = code.indexOf(zc_consts.bibHead);
        if (cIdx === 0 || bIdx === 0) {
            const field = zc_createCitationField(range);
            field.Code.Text = zc_tweakFieldCode(code, 'Microsoft');
            if (cIdx === 0) {
                try {
                    csl = JSON.parse(code.substring(zc_consts.citationHead.length));
                    rich = csl.properties.formattedCitation;
                    if (!zc_replaceFieldRichText(field, rich)) {
                        console.error(`Failed to set rich text while converting hyperlink to field`);
                    }
                }
                catch (error) {
                    console.error(`Encountered error while trying to recover citation texts: ${error}`);
                }
            }
            hyperlink.Range.Select();
            const sel = hyperlink.Range.Document.ActiveWindow.Selection;
            hyperlink.Delete();
            sel.TypeBackspace();
        }
        else {
            console.warn(`Failed to convert a Zotero hyperlink to field: ${hyperlink.TextToDisplay}`);
        }
    }
}

/**
 * Get CSL json from field code.
**/
function zc_getCslData(field) {
    let data = null;
    const code =field.Code.Text;
    const idx0 = code.indexOf(zc_consts.citationHead);
    const idx1 = code.indexOf(zc_consts.citationHeadM);
    const idx = (idx0 === 0 ? zc_consts.citationHead.length :
                (idx1 === 1 ? zc_consts.citationHeadM.length + 1: 0));
    if (idx > 0) {
        data = JSON.parse(code.substring(idx));
    }
    return data;
}

/**
 * Tweak the field code to make it look like it's created in Google Docs or ms word.
**/
function zc_tweakFieldCode(code, flavor) {
    let code_ = code.trim();
    if (flavor === 'Google') {
        if (code_.indexOf(zc_consts.bibHeadM) === 0) {
            code_ = code_.replace(zc_consts.bibHeadM, zc_consts.bibHead);
        }
        if (code_.indexOf(zc_consts.citationHeadM) === 0) {
            code_ = code_.replace(zc_consts.citationHeadM, zc_consts.citationHead);
        }
    }
    else {
        assert(flavor === 'Microsoft');
        if (code_.indexOf(zc_consts.bibHead) === 0) {
            code_ = code_.replace(zc_consts.bibHead, zc_consts.bibHeadM);
        }
        if (code_.indexOf(zc_consts.citationHead) === 0) {
            code_ = code_.replace(zc_consts.citationHead, zc_consts.citationHeadM);
        }
        code_ = ' ' + code_ + ' ';
    }
    return code_;
}

/**
 * Create a citation field at the given range with temporary code and text and registery it.
**/
function zc_createCitationField(range) {
    const doc = range.Document;
    range.Collapse(wps.Enum.wdCollapseEnd);
    const field = doc.Fields.Add(range, wps.Enum.wdFieldAddin);
    assert(field);
    field.Code.Text = zc_consts.tempCitation;
    field.Result.Text = zc_consts.tempCitationText;
    return field;
}

/**
 * Test if a Zotero field is adjacent to another one.
 * TODO: The `adjacent` property is not documented by Zotero, so my definition might not be consistent with others.
**/
function zc_isFieldAdjacent(field) {
    if (field && zc_isZoteroField) {
        const prevField = field.Previous;
        const nextField = field.Next;
        if (prevField && zc_isZoteroField(prevField)) {
            if (prevField.Result.End === field.Result.Start) {
                return true;
            }
        }
        if (nextField && zc_isZoteroField(nextField)) {
            if (nextField.Result.Start === field.Result.End) {
                return true;
            }
        }
        return false;
    }
    console.warn('Trying to test adjacence for null/undefined or non-Zotero field, will always return false!');
    return false;
}

function zc_isFieldInFootnote(field) {
    if (field) {
        return field.Result.Footnotes.Count > 0;
    }
    return false;
}

/**
 * Make a json data representing a registered citation field for Zotero to read.
 * Return only when its a valid Zotero field.
**/
function zc_getZoteroFieldData(field, noTweak) {
    if (field && zc_isZoteroField(field)) {
        const docId = zc_getDocumentId(field.Result.Document);
        const client = zc_getClientById(docId);

        // All citation fields should already be registered.
        const fId = client.getFieldId(field);
        assert(fId);

        const text = field.Result.Text;
        let code = field.Code.Text;
        if (!noTweak) {
            code = zc_tweakFieldCode(code, 'Google');
        }

        // Determine if the field is adjacent to another one.
        let adjacent = zc_isFieldAdjacent(field);

        // Get noteIndex from CSL data.
        const defaultNoteIndex = zc_isFieldInFootnote(field) ? 1 : 0;
        const csl = zc_getCslData(field);
        const noteIndex = csl ? csl.properties.noteIndex : defaultNoteIndex;

        // The documentation says to return an array.
        // However, Google Docs returns a map just like this:
        const data = {
            id: fId,
            text: text,
            code: code,
            adjacent: adjacent,
            noteIndex: noteIndex
        };

        return data;
    }
}

/**
 * Clean zombie fields that somehow didn't get updated after creation.
**/
function zc_cleanTempFields(doc) {
    const docId = zc_getDocumentId(doc);
    const client = zc_getClientById(docId);
    if (doc && doc.Fields) {
        for (let i = doc.Fields.Count; i > 0; i--) {
            const field = doc.Fields.Item(i);
            if (field.Code.Text === zc_consts.tempCitation) {
                client.unregisterField(field);
                field.Delete();
            }
        }
    }
}

/**
 * Set rich text for zotero fields.
**/
function zc_replaceFieldRichText(field, text, bibStyle) {
    if (!field) return false;

    let ret = true;
    const doc = field.Result.Document;
    // Guard the field without being automatically deleted.
    // I was using '{}', but the subsequent paragraph instead of '}' gets deleted if the reference field is created in MS Word.
    field.Result.Text = '!';
    // Move behind the guard.
    let range = field.Result;
    range.Collapse(wps.Enum.wdCollapseStart);
    // This is neccessary if there's a paragraph character at start. 
    // NOTE: Range objects have all the methods of Selection.
    range.MoveStartUntil('!');
    range.MoveStart(wps.Enum.wdCharacter, 1);
    // Insert text with formatting
    let bibStyle_ = bibStyle;
    const isBib = field.Code.Text.indexOf('ZOTERO_BIBL') >= 0;
    if (isBib) {
        // Add new paragraph if there's no next paragraph,
        // so we don't mess up with paragraph styles outside the field.
        const paras = field.Result.Paragraphs;
        if (!paras.Item(paras.Count).Next()) {
            const range_ = field.Result;
            range_.Collapse(wps.Enum.wdCollapseEnd);
            // step out of the field range
            range_.MoveStart(wps.Enum.wdCharacter, 1);
            range_.InsertParagraph();
        }
        if (!bibStyle_) {
            bibStyle_ = zc_getBibStyle(doc, field);
        }
        if (bibStyle_) {
            zc_insertBibEntries(range, text, bibStyle_);
        }
        else {
            range.InsertAfter("Missing bibliography formatting style, please restart Zotero and click update");
        }
    }
    else {
        ret = zc_insertRichText(range, text);
        if (!ret) range.InsertAfter('{Error}');
    }
    // Remove the guarding <
    if (field.Result.Text.length > 1) {
        range = field.Result;
        range.Collapse(wps.Enum.wdCollapseStart);
        range.Delete(wps.Enum.wdCharacter, 1);
    }

    return ret;
}

// An interface supplied to the zotero client to operate WPS.
var zc_wps = {
    /**
     * Insert a citation field at cursor and register it.
     * Returns a data object representing the field.
    **/
    insertField: function(docId, inFootnote, insertRange) {
        const client = zc_getClientById(docId);
        const doc = zc_getDocumentById(docId);
        let range = insertRange ? insertRange : doc.ActiveWindow.Selection.Range;
        if (inFootnote) {
            // Create footnote and move into it.
            range.Collapse(wps.Enum.wdCollapseEnd);
            const footnote = doc.Footnotes.Add(range);
            range = footnote.Range;
        }
        const field = zc_createCitationField(range);
        assert(client.registerField(field));

        // Move cursor to citation end
        if (!inFootnote) {
            field.Select();
            const sel = doc.ActiveWindow.Selection;
            sel.Collapse(wps.Enum.wdCollapseEnd);
        }

        const data = zc_getZoteroFieldData(field);
        assert(data);

        return data;
    },

    /**
     * Get the data of all citation fields as an array with each item consisting of field ID, text, code and adjacent.
    **/
    getOrderedCitationData: function(docId) {
        const doc = zc_getDocumentById(docId);
        const fieldsDataArr = [];
        // Fields in main texts.
        for (let i = 1; i <= doc.Fields.Count; i++) {
            const data = zc_getZoteroFieldData(doc.Fields.Item(i));
            if (data) fieldsDataArr.push(data);
        }
        // Fields in footnotes
        for (let i = 1; i <= doc.Footnotes.Count; i++) {
            const range = doc.Footnotes.Item(i).Range;
            for (let j = 1; j <= range.Fields.Count; j++) {
                const data = zc_getZoteroFieldData(range.Fields.Item(j));
                if (data) {
                    // Prevent adjacent fields to be added twice.
                    if (fieldsDataArr.length > 0 && fieldsDataArr[fieldsDataArr.length-1].id === data.id) continue;
                    fieldsDataArr.push(data)
                }
            }
        }
        // TODO: In future, add fields in endnotes if endnotes are supported.
        return fieldsDataArr;
    },

    /**
     * Get the data of fields before and after the cursor.
     * When there's a visual selection, the cursor is the selection end.
    **/
    getFieldsNearCursor: function(docId) {
        // NOTE: Return only the the field before the cursor just like other word processor integration plugins.
        const doc = zc_getDocumentById(docId);
        const client = zc_getClientById(docId);
        const range = doc.ActiveWindow.Selection.Range;
        range.Collapse(wps.Enum.wdCollapseEnd);
        const fields = [];
        for (let i = 1; i <= range.Fields.Count; i++) {
            const field = range.Fields.Item(i);
            if (client.registerField(field)) {
                fields.push(field);
            }
        }
        if (fields.length < 1) {
            // extend range to include fields before the cursor
            range.MoveStart(wps.Enum.wdCharacter, -1);
            for (let i = 1; i <= range.Fields.Count; i++) {
                const field = range.Fields.Item(i);
                if (client.registerField(field)) {
                    fields.push(field);
                }
            }
        }
        return fields.length > 0 ? zc_getZoteroFieldData(fields[0]) : null;
    },

    isInLink: function(docId) {
        const doc = zc_getDocumentById(docId);
        const range = doc.ActiveWindow.Selection.Range;
        range.Collapse(wps.Enum.wdCollapseEnd);
        return range.Hyperlinks.Count > 0 ? true : false;
    },

    displayDialog: function(msg, icon, buttons) {
        var r = 0;
        if (buttons <= 0) {
            zc_alert(msg);
            r = 1;
        } else if (buttons <= 2) {
            r = confirm('WPS-Zotero: ' + msg) ? 1 : 0;
        } else {
            // TODO: Make a three button dialog.
            r = confirm('WPS-Zotero: ' + msg + '\n\n' + "(There are 3 options: 'ok', 'no' and 'cancel', this is page 1/2, 'no' and 'cancel' can be chosen by selecting 'cancel' to open another dialog)");
            if (!r) {
                r = confirm('WPS-Zotero: ' + msg + '\n\n' + "(There are 3 options, this is page 2/2, now 'ok' and 'cancel' represents 'no' and 'cancel')");
                r = r ? 1 : 0;
            } else {
                r = 2;
            }
        }
        delete icon;
        return r;
    },

    activate: function(docId) {
        zc_getDocumentById(docId).Activate();
    },

    getDocData: function(docId) {
        let dataStr = zc_getDocProperty(zc_getDocumentById(docId), zc_consts.prefDocDataName);
        // MS Word compatibility
        dataStr = dataStr.replaceAll('value="Field"', 'value="Http"');
        if (zc_testDocDataVer(dataStr) === 4) {
            dataStr = JSON.stringify(dataStr);
        }
        return dataStr;
    },

    setDocData: function(docId, dataStr) {
        // MS Word compatibility
        const dataStr_ = dataStr.replaceAll('value="Http"', 'value="Field"');
        zc_setDocProperty(zc_getDocumentById(docId), zc_consts.prefDocDataName, dataStr_);
    },

    setFieldCode: function(docId, fieldId, code) {
        // Compatible with MS Word integration
        const code_ = zc_tweakFieldCode(code, 'Microsoft');
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (!field || field.Index < 1) {
            throw new Error(`field with the id of ${fieldId} is not valid!`);
        }
        field.Code.Text = code_;
    },

    getFields: function(docId) {
        const records = this.getOrderedCitationData(docId);
        // This should be needed only here!
        // NOTE: Zotero will try to set temp field code to `{}`, but we don't take that order because it will result in invisible fields. As a workaround, we keep `TEMP` as the code for temp fields, but report to Zotero it's `{}`.
        for (const rec of records) {
            if (rec.code === zc_consts.tempCitation) {
                rec.code = '{}';
            }
        }
        return records;
    },

    insertRich: function(docId, text) {
        const doc = zc_getDocumentById(docId);
        if (!zc_insertRichText(doc.ActiveWindow.Selection.Range, text)) {
            console.warn(`Invalid xml string: ${text}, insert it as plain string instead!`);
            const range = doc.ActiveWindow.Selection.Range;
            range.InsertAfter(text);
        };
    },

    deleteField: function(docId, fieldId) {
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (field) {
            const ret = client.unregisterField(fieldId);
            field.Delete();
            return Boolean(ret);
        }
        else {
            return false;
        }
    },

    selectField: function(docId, fieldId) {
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (field && field.Index > 0) {
            field.Select();
            return true;
        }
        return false;
    },

    removeFieldCode: function(docId, fieldId) {
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (field && field.Index > 0) {
            client.unregisterField(field);
            field.Unlink();
            return true;
        }
        return false;
    },

    /**
     * Store bibliography style as a property and as a custom document property.
    **/
    setBibStyle: function(docId, firstLineIndent, indent, lineSpacing, entrySpacing, tabStops, tabStopsCount) {
        this.bibStyle = {
            firstLineIndent: firstLineIndent,
            indent: indent,
            lineSpacing: lineSpacing,
            entrySpacing: entrySpacing,
            tabStops: tabStops,
            tabStopsCount: tabStopsCount
        };
        // Store bib style to document
        zc_setDocProperty(zc_getDocumentById(docId), zc_consts.bibStyleDocDataName, JSON.stringify(this.bibStyle));
    },

    /**
     * Set field texts. Used for both citation fields and bibliography fields.
    **/
    setFieldText: function(docId, fieldId, text, isRich) {
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (field && field.Index > 0) {
            if (isRich) {
                const textSafe = '<div>' + text  + '</div>';
                if (!zc_replaceFieldRichText(field, textSafe, this.bibStyle)) {
                    console.warn(`Failed to insert rich text: ${text}, insert as plain text instead!`);
                    field.Result.Text = text;
                }
            }
            else {
                field.Result.Text = text;
            }
            return true;
        }
        return false;
    },

    getFieldText: function(docId, fieldId) {
        const client = zc_getClientById(docId);
        const field = client.getField(fieldId);
        if (field && field.Index > 0) {
            return field.Result.Text;
        }
        return '';
    },

    convertToNoteType: function(docId, fieldIds, toNoteTypes) {
        const client = zc_getClientById(docId);
        assert(fieldIds.length === toNoteTypes.length);
        for (let i = 0; i < fieldIds.length; i++) {
            const fId = fieldIds[i];
            const toType = toNoteTypes[i];
            assert(toType < 2);
            const field = client.getField(fId);
            assert(field);
            const csl = zc_getCslData(field);
            // fields needs conversion should be citation fields.
            assert(csl);
            // NOTE: Only support in-text and footnote. So there's only 0 or 1.
            const nowType = csl.properties.noteIndex > 0 ? 1 : 0;
            const conv = nowType - toType;
            if (conv === 1) {
                zc_moveFieldToMain(field);
            }
            else if (conv === -1) {
                zc_moveFieldToFootnote(field);
            }
        }
    },

    exportDocument: function(docId) {
        const doc = zc_getDocumentById(docId);

        // clean all zombie fields
        zc_cleanTempFields(doc);

        // Add head info
        let range = doc.Range(0, 0);
        range.InsertAfter(zc_consts.exportedHead);
        range.Collapse(wps.Enum.wdCollapseEnd);
        range.InsertParagraph();
        range.Collapse(wps.Enum.wdCollapseEnd);
        range.InsertParagraph();
        range.Collapse(wps.Enum.wdCollapseEnd);
        range.InsertAfter('The Zotero citations in this document have been converted to a format that can be safely transferred between word processors. Open this document in a supported word processor and press Refresh in the Zotero plugin to continue working with the citations.');
        range.Collapse(wps.Enum.wdCollapseEnd);
        range.InsertParagraph();
        range.Collapse(wps.Enum.wdCollapseEnd);
        range.InsertParagraph();

        // Turn fields to hyperlinks
        // Fields in main text.
        for (let i = doc.Fields.Count; i > 0; i--) {
            zc_convertFieldToHyperlink(doc.Fields.Item(i));
        }
        // Fields in footnotes
        for (let i = doc.Footnotes.Count; i > 0; i--) {
            const fRange = doc.Footnotes.Item(i).Range;
            for (let j = fRange.Fields.Count; j > 0; j--) {
                zc_convertFieldToHyperlink(fRange.Fields.Item(j));
            }
        }
        // TODO: Scan for fields in endnotes as well in future if endnote is to be supported.

        // Add document data at the end
        const docData = zc_getDocProperty(doc, zc_consts.prefDocDataName);
        range.Start = doc.Content.End;
        range.End = doc.Content.End;
        range.InsertAfter(zc_consts.exportedPrefHead + docData);
        range.Hyperlinks.Add(range, zc_consts.zoteroLink);
    },

    importDocument(docId) {
        const doc = zc_getDocumentById(docId);
        // Check document head
        if (doc.Range(0, 24).Text === zc_consts.exportedHead) {
            // Check if there's a document preferences paragraph at the end.
            if (doc.Hyperlinks.Count > 0) {
                const lastHyperlink = doc.Hyperlinks.Item(doc.Hyperlinks.Count);
                const lastHyperlinkText = lastHyperlink.TextToDisplay;
                if (lastHyperlinkText.indexOf(zc_consts.exportedPrefHead) === 0) {
                    // Set document data
                    dataStr = lastHyperlinkText.substring(zc_consts.exportedPrefHead.length);
                    zc_setDocProperty(doc, zc_consts.prefDocDataName, dataStr);
                    lastHyperlink.Range.Select();
                    lastHyperlink.Delete();
                    const sel = doc.ActiveWindow.Selection;
                    sel.TypeBackspace();

                    sel.Start = 0;
                    sel.End = 0;
                    sel.MoveEnd(wps.Enum.wdParagraph, 4);
                    sel.TypeBackspace();

                    // Turn hyperlinks to fields
                    // Hyperlinks in main text.
                    for (let i = doc.Hyperlinks.Count; i > 0; i--) {
                        zc_convertHyperlinkToField(doc.Hyperlinks.Item(i));
                    }
                    // Hyperlinks in footnotes
                    for (let i = doc.Footnotes.Count; i > 0; i--) {
                        const fRange = doc.Footnotes.Item(i).Range;
                        for (let j = 1; j <= fRange.Hyperlinks.Count; j++) {
                            zc_convertHyperlinkToField(fRange.Hyperlinks.Item(j));
                        }
                    }
                    // TODO: Scan for fields in endnotes as well in future if endnote is to be supported.
                }
            }
        }
    },

    convertPlaceholderLinks(docId, placeholderIds, noteType) {
        const doc = zc_getDocumentById(docId);
        const client = zc_getClientById(docId);
        const fieldDataArr = [];
        const _insertField = this.insertField;
        function _convert(link) {
            if (link.Address.indexOf(zc_consts.placeholderUrl) === 0 &&
                placeholderIds.indexOf(link.Address.substr(zc_consts.placeholderUrl.length)) >= 0) {
                const phId = link.Address.substr(zc_consts.placeholderUrl.length);
                link.Range.Select();
                const sel = link.Range.Document.ActiveWindow.Selection;
                link.Delete();
                sel.TypeBackspace();
                const fieldData = _insertField(docId, noteType, sel.Range);
                // Re-register the field with placeholder ID
                const field = client.getField(fieldData.id);
                client.unregisterField(field);
                assert(phId === client.registerField(field, phId));
                fieldData.id = phId;
                fieldDataArr.push(fieldData);
            }
        }
        for (let i = doc.Hyperlinks.Count; i > 0; i--) {
            _convert(doc.Hyperlinks.Item(i));
        }
        for (let i = doc.Footnotes.Count; i > 0; i--) {
            const fRange = doc.Footnotes.Item(i).Range;
            for (let j = fRange.Hyperlinks.Count; j > 0; j--) {
                _convert(fRange.Hyperlinks.Item(j));
            }
        }
        // for (let i = doc.Endnotes.Count; i > 0; i--) {
        //     const eRange = doc.Endnotes.Item(i).Range;
        //     for (let j = eRange.Hyperlinks.Count; j > 0; j--) {
        //         _convert(eRange.Hyperlinks.Item(j));
        //     }
        // }
        return fieldDataArr;
    },

    init: function(docId) {
        // Index existing fields
        zc_indexCitationFields(zc_getDocumentById(docId));
    },

    reset: function(docId) {
        // IMPORTANT: Release references on field objects. Should be called as soon as possible when the field map is not needed.
        // NOTE: Holding strong references to fields will cause serious problems when fields get deleted. Also, you cannot hold weak references because the field objects returned by the wps api is just dummies and they will be garbage colleted even when the actual fields still exist.
        const doc = zc_getDocumentById(docId);
        const client = zc_getClientById(docId);
        client.clearAllFieldIds();
        zc_cleanTempFields(doc);
    }
}